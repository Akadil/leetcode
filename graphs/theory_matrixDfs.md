<div class="my-div"><h1 id="matrix-dfs">Matrix DFS</h1>
<hr>
<p>How do we go about applying DFS to graphs? This is best shown with an example.</p>
<p>Suppose we are given the following question to solve:</p>
<blockquote>
<p>Q: Count the unique paths from the top left to the bottom right. A single path may only move along 0's and can't visit the same cell more than once.</p>
</blockquote>
<div class="code-toolbar"><pre class="language-cpp" tabindex="0"><code class="hljs language-cpp"><span class="token keyword">int</span> grid<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="toolbar"><div class="toolbar-item"><button class="copy-to-clipboard-button" type="button" data-copy-state="copy"><span>Copy</span></button></div></div></div>
<p>In this problem, it is all a matter of choices. You might think of this as similar to backtracking and you would be right. We have mentioned before that DFS is recursive in nature and and we will be using recursion for this. Firstly, we need to think of our base case(s). Well, we know that we can move in all four directions except diagonally. This means that if we go out of bounds, we can return zero.</p>
<p>We know that this will be a brute-force DFS with backtracking since at any point in our path, we might not have a valid way to reach the bottom right, in which case, we will have to backtrack.</p>
<p>For starters, let's establish about our base cases. Since we are trying to find the number of unique paths, we need to keep count of the valid paths from each vertex.</p>
<hr>
<h2 id="the-base-cases">The base cases</h2>
<h4 id="1-a-unique-path-does-not-exist">1. A unique path does not exist</h4>
<p>Since we are allowed to move in all four directions, it is possible that during our traversal, we end up going out of bounds. This means either our column, <code class="hljs language-ebnf">c</code>, or our row, <code class="hljs language-ebnf">r</code> becomes negative, or goes beyond the length of our matrix. It does not matter which of <code class="hljs language-ebnf">r</code> and <code class="hljs language-ebnf">c</code> goes out of bounds because we need a valid <code class="hljs language-ebnf">c</code> <strong>AND</strong> a valid <code class="hljs language-ebnf">r</code> to perform our search. We cannot perform a search on <code class="hljs language-apache">matrix[-1][3]</code>.</p>
<p>If we have already visited a coordinate, or the current coordinate is 1, then a valid path does not exist through that coordinate.</p>
<p>So because a valid path does not exist in all of the aforementioned cases, we will return 0, which denotes absence of a unique path. We shall see this in our code soon.</p>
<h4 id="2-a-unique-path-does-exist">2. A unique path does exist</h4>
<p>If we have not returned <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> from the first case, and we have reached the right-most column and the bottom-most row, it must be the case that we have found a valid path. Remember, our definition of a valid path is if a path exists from <code class="hljs language-apache">matrix[0][0]</code> to <code class="hljs language-apache">matrix[3][3]</code>. We can now return <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> and this will increment our count for the number of unique paths.</p>
<hr>
<h2 id="implementation">Implementation</h2>
<p>To ensure that we don't visit a coordinate more than once, we add it to a global HashSet, once visited.</p>
<p>Then, at any given coordinate, we can recursively perform our DFS on <code class="hljs language-apache">r+1</code>, <code class="hljs language-apache">r-1</code>, <code class="hljs language-apache">c+1</code> and <code class="hljs language-apache">c-1</code>. If our recursive call returns <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>, our <code class="hljs language-applescript">count</code> will be incremented and if it returns <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>, adding it to count will make no difference.</p>
<p>At each recursive call, we can remove all of the rows and columns that led us to an invalid path. This way, we can ensure to visit them again, but take a different direction and explore if a valid path exists from that direction.</p>
<p>In the code below, we have our aforementioned base cases set up. We then add the current row and column to our set. Our count is initialized with <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> because we need to keep track of all the possible unique paths we have to our destination at any given vertex. Once our recursive calls return, we can remove the visited vertices from our set. Again, this is because they can be part of another unique path, just from a different source. So, when we backtrack, we can visit them again.</p>
<div class="code-toolbar"><pre class="language-cpp" tabindex="0"><code class="hljs language-cpp"><span class="token comment">// Count paths (backtracking)</span>
<span class="token comment">// In C++ it's easier to use a 2D array for visit rather than a hashset.</span>
<span class="token keyword">int</span> <span class="token function">dfs</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span><span class="token operator">&amp;</span> grid<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">,</span> <span class="token keyword">int</span> c<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span><span class="token operator">&amp;</span> visit<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> ROWS <span class="token operator">=</span> grid<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> COLS <span class="token operator">=</span> grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">min</span><span class="token punctuation">(</span>r<span class="token punctuation">,</span> c<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> r <span class="token operator">==</span> ROWS <span class="token operator">||</span> c <span class="token operator">==</span> COLS <span class="token operator">||</span>
        visit<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">||</span> grid<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">==</span> ROWS <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> c <span class="token operator">==</span> COLS <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    visit<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    count <span class="token operator">+=</span> <span class="token function">dfs</span><span class="token punctuation">(</span>grid<span class="token punctuation">,</span> r <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> c<span class="token punctuation">,</span> visit<span class="token punctuation">)</span><span class="token punctuation">;</span>
    count <span class="token operator">+=</span> <span class="token function">dfs</span><span class="token punctuation">(</span>grid<span class="token punctuation">,</span> r <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> c<span class="token punctuation">,</span> visit<span class="token punctuation">)</span><span class="token punctuation">;</span>
    count <span class="token operator">+=</span> <span class="token function">dfs</span><span class="token punctuation">(</span>grid<span class="token punctuation">,</span> r<span class="token punctuation">,</span> c <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> visit<span class="token punctuation">)</span><span class="token punctuation">;</span>
    count <span class="token operator">+=</span> <span class="token function">dfs</span><span class="token punctuation">(</span>grid<span class="token punctuation">,</span> r<span class="token punctuation">,</span> c <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> visit<span class="token punctuation">)</span><span class="token punctuation">;</span>
    visit<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> count<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="toolbar"><div class="toolbar-item"><button class="copy-to-clipboard-button" type="button" data-copy-state="copy"><span>Copy</span></button></div></div></div>
<p>To visualize the above on our matrix, we can break down our algorithm into finding the initial unique path, and then backtracking to find another potential unique path.</p>
<h3 id="1-find-the-first-unique-path">1. Find the first unique path</h3>
<p><img src="https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/7717e227-5da3-4b91-fe73-b25065d78c00/sharpen=1" alt="recursive-dfs"></p>
<h3 id="2-backtrack-to-find-another-potential-unique-path">2. Backtrack to find another potential unique path</h3>
<blockquote>
<p>The red dotted line represents another unique path which is reached from <code class="hljs language-apache">matrix[0][3]</code>.</p>
</blockquote>
<p><img src="https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/c1fd94d4-7a68-4e8d-4f91-5a5f3ec92c00/sharpen=1" alt="recursive-dfs"></p>
<p>Our function returns <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span>, denoting there exist <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span> unique paths from <code class="hljs language-clojure">(0,0)</code> to <code class="hljs language-clojure">(3,3)</code>.</p>
<hr>
<h2 id="time-complexity">Time Complexity</h2>
<p>By now, we know that we only consider the worst case. In the worst case, we might need to visit every single row and column. At every coordinate, we can move in all four directions. Each one of the coordinates that are reached by moving in each those four directions will also be able to move up, down, left or right. We have four options from each position. If we are to create a decision tree out of this, each node will have at most four children. The tree has a branching factor of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4</span></span></span></span> and the height of the tree is the size of the matrix which is just <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>∗</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n*m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4653em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span>, where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> is the number of rows and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> is the number of columns.</p>
<p>Therefore, we get <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>4</mn><mrow><mi>n</mi><mi>m</mi></mrow></msup></mrow><annotation encoding="application/x-tex">4^{{nm}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord">4</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">nm</span></span></span></span></span></span></span></span></span></span></span></span></span>.</p>
<blockquote>
<p>The space complexity will be the entire call stack since this is recursive. Therefore, it will be <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mtext>&nbsp;</mtext><mo>∗</mo><mtext>&nbsp;</mtext><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n\ *\ m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace">&nbsp;</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace">&nbsp;</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span>.</p>
</blockquote>
<hr>
</div>