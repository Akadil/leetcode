<div class="my-div"><h1 id="adjacency-list">Adjacency List</h1>
<hr>
<p>An adjacency list is probably the "nicest" format out of the three we have covered. Here, we are given a list of directed edges and we have to connect the source to the destinations. In other words, we have to build our adjacency list given an array of edges.</p>
<p>The code below demonstrates how we can build an adjacency list. We can use a hashmap where the key is a vertex and it maps to a list of its neighbors, which are also vertices. A hash map works here because we are assuming that all of the values keys are unique.</p>
<div class="code-toolbar"><pre class="language-cpp" tabindex="0"><code class="hljs language-cpp"><span class="token comment">// GraphNode used for adjacency list</span>
<span class="token keyword">class</span> <span class="token class-name">GraphNode</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    string<span class="token operator">&amp;</span> val_<span class="token punctuation">;</span>
    vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> neighbors_<span class="token punctuation">;</span>
    <span class="token function">GraphNode</span><span class="token punctuation">(</span>string<span class="token operator">&amp;</span> val<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">val_</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// Or use a HashMap</span>
<span class="token comment">// unordered_map&lt;string, vector&lt;string&gt;&gt; adjList = </span>
<span class="token comment">//     {{"A", vector&lt;string&gt;{}}, {"B", vector&lt;string&gt;{}}};</span>

<span class="token comment">// Given directed edges, build an adjacency list</span>
vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;&gt;</span> edges <span class="token operator">=</span> 
    <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token string">"A"</span><span class="token punctuation">,</span> <span class="token string">"B"</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token string">"B"</span><span class="token punctuation">,</span> <span class="token string">"C"</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token string">"B"</span><span class="token punctuation">,</span> <span class="token string">"E"</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token string">"C"</span><span class="token punctuation">,</span> <span class="token string">"E"</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token string">"E"</span><span class="token punctuation">,</span> <span class="token string">"D"</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
unordered_map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;&gt;</span> adjList<span class="token punctuation">;</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> edge<span class="token operator">:</span>  edges<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    string src <span class="token operator">=</span> edge<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dst <span class="token operator">=</span> edge<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    adjList<span class="token punctuation">[</span>src<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>dst<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="toolbar"><div class="toolbar-item"><button class="copy-to-clipboard-button" type="button" data-copy-state="copy"><span>Copy</span></button></div></div></div>
<p><img src="https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/72a1579b-0589-464b-e288-3bc754b6de00/sharpen=1" alt=""></p>
<hr>
<h2 id="dfs-on-an-adjacency-list">DFS on an adjacency list</h2>
<p>Let's say that we wanted to count the number of paths that lead from a source to destination.</p>
<p>In the code below, we have an adjacency list, a source, and a <code class="hljs language-aspectj">target</code>. Similar to matrix traversal, we will make use of a hashset called <code class="hljs language-ebnf">visit</code> to keep track of the vertices that we have already visited.</p>
<p>We will then recursively run DFS on our list until we reach the target node, after which we will return 1. Once we have found a path, we will backtrack by removing nodes from our <code class="hljs language-ebnf">list</code> and return the <code class="hljs language-applescript">count</code>.</p>
<div class="code-toolbar"><pre class="language-cpp" tabindex="0"><code class="hljs language-cpp"><span class="token comment">// Count paths (backtracking)</span>
<span class="token keyword">int</span> <span class="token function">dfs</span><span class="token punctuation">(</span>string<span class="token operator">&amp;</span> node<span class="token punctuation">,</span> string<span class="token operator">&amp;</span> target<span class="token punctuation">,</span> unordered_map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;&gt;</span><span class="token operator">&amp;</span> adjList<span class="token punctuation">,</span>
    unordered_set<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span><span class="token operator">&amp;</span> visit<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>visit<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    visit<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>string neighbor<span class="token operator">:</span> adjList<span class="token punctuation">[</span>node<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        count <span class="token operator">+=</span> <span class="token function">dfs</span><span class="token punctuation">(</span>neighbor<span class="token punctuation">,</span> target<span class="token punctuation">,</span> adjList<span class="token punctuation">,</span> visit<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    visit<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> count<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="toolbar"><div class="toolbar-item"><button class="copy-to-clipboard-button" type="button" data-copy-state="copy"><span>Copy</span></button></div></div></div>
<p>In the image below, the above algorithm is demonstrated. The red check marks indicate that a node has been visited and is in the set.</p>
<p><img src="https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/40e15306-bafb-4aa6-9f00-4afe80842e00/sharpen=1" alt=""></p>
<h3 id="time-complexity">Time Complexity</h3>
<p>This backtracking is exponential. In the worst case, each node is connected to every other node in the graph. Recall the rule that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mtext>&nbsp;</mtext><mo>&lt;</mo><mo>=</mo><mtext>&nbsp;</mtext><msup><mi>V</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">E\ &lt;=\ V^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mspace">&nbsp;</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;=</span><span class="mspace">&nbsp;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>. So, let us say that each vertex has <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> edges. If we are to create a decision tree which determines how many vertices can be by each vertex, and the height of that tree is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span>, this means that in the worst case, we will have to do <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>N</mi><mi>v</mi></msup></mrow><annotation encoding="application/x-tex">N^v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span></span></span></span></span></span></span></span> work for reasons that are very similar to what we discussed in the matrix chapter. </p>
<hr>
<h2 id="bfs-on-an-adjacency-list">BFS on an adjacency list</h2>
<p>Running BFS is similar to what we have seen before. Let us say that our goal is to find the <strong>shortest path</strong> from node to target. By shortest path, we mean reaching the destination by visiting fewest vertices possible.</p>
<p>Our code looks very similar to when we did Matrix BFS, except in this case, we don't have to worry about edge cases. We will keep increasing the length at each level, until we find the <code class="hljs language-aspectj">target</code> vertex.</p>
<div class="code-toolbar"><pre class="language-cpp" tabindex="0"><code class="hljs language-cpp"><span class="token comment">// Shortest path from node to target.</span>
<span class="token keyword">int</span> <span class="token function">bfs</span><span class="token punctuation">(</span>string<span class="token operator">&amp;</span> node<span class="token punctuation">,</span> string<span class="token operator">&amp;</span> target<span class="token punctuation">,</span> unordered_map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;&gt;</span><span class="token operator">&amp;</span> adjList<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> length <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    unordered_set<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> visit<span class="token punctuation">;</span>
    queue<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> queue<span class="token punctuation">;</span>
    visit<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>queue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> queueLength <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> queueLength<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            string curr <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            queue<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>curr <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> length<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span>string neighbor<span class="token operator">:</span> adjList<span class="token punctuation">[</span>curr<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>visit<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>neighbor<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    visit<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>neighbor<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>neighbor<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        length<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> length<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="toolbar"><div class="toolbar-item"><button class="copy-to-clipboard-button" type="button" data-copy-state="copy"><span>Copy</span></button></div></div></div>
<p>Looking at the image below, the above piece of code will return 2.</p>
<p><img src="https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/dd4cf5f7-598f-4702-ac9d-684872d0e100/sharpen=1" alt=""></p>
<h3 id="time-complexity-1">Time Complexity</h3>
<p>We learned before that the number of edges in a graph is upper bounded by <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>V</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">V^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>. However, we know that in this case, we don't have self loops and we don't have the maximal number of edges. Therefore, we can say that the time complexity is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>V</mi><mtext>&nbsp;</mtext><mo>+</mo><mtext>&nbsp;</mtext><mi>E</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(V\ +\ E)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace">&nbsp;</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace">&nbsp;</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span>, where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span> is the number of vertices and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span> is the number of edges. This is because in the worst case, our BFS has to consider all paths to all possible vertices, which means the total work will be the number of vertices and edges combined.</p>
<hr>
<h2 id="closing-notes">Closing Notes</h2>
<p>That is all we are going to cover on graphs. You might not believe it but this is actually just scratching the surface and covering the basics. After all, there is a whole field of study called Graph Theory. Graphs can get even more complicated and there are a lot more algorithms that are specific to graphs. You can find these in the "Advanced Algorithms" course.</p>
<hr>
</div>