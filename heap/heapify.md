<div class="my-div"><h1 id="heapify">Heapify</h1>

<p>Recall that to build a binary search tree, the time complexity is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mtext>&nbsp;</mtext><mi>l</mi><mi>o</mi><mi>g</mi><mtext>&nbsp;</mtext><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n\ log\ n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace">&nbsp;</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace">&nbsp;</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>. We could build our heap the same way and those operations would also run in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mtext>&nbsp;</mtext><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(log\ n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace">&nbsp;</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> time. Heapify tells us there is a better way of doing it. It allows us to perform this operation in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> time.</p>

<h2 id="concept">Concept</h2>
<p>The idea behind using heapify to build a heap is to satisfy the structure and the order property. We need to make sure that our binary heap is a complete binary tree and that every node's value is at most its parent's value.</p>
<p>Because the leaf nodes can't violate the min-heap properties, there is no need to perform <code class="hljs language-stylus">heapify()</code> on them. </p>
<p>Since we are skipping all of the leaf nodes, we only need to start at <code class="hljs language-arcade">heap.length // 2</code>. Then, we need to percolate down the exact same way we did in the previous chapter in the <code class="hljs language-stylus">pop()</code> method. We will not be going over the code in detail as majority of it is the same as the <code class="hljs language-stylus">pop()</code> method. </p>
<div class="code-toolbar"><pre class="language-cpp" tabindex="0"><code class="hljs language-cpp"><span class="token keyword">void</span> <span class="token function">heapify</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 0-th position is moved to the end</span>
    arr<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<br>
    heap_ <span class="token operator">=</span> arr<span class="token punctuation">;</span>
    <span class="token keyword">int</span> cur <span class="token operator">=</span> <span class="token punctuation">(</span>heap_<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// Percolate down</span>
        <span class="token keyword">int</span> i <span class="token operator">=</span> cur<span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> i <span class="token operator">&lt;</span> heap_<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> i <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> heap_<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
            heap_<span class="token punctuation">[</span><span class="token number">2</span> <span class="token operator">*</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> heap_<span class="token punctuation">[</span><span class="token number">2</span> <span class="token operator">*</span> i<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span>
            heap_<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> heap_<span class="token punctuation">[</span><span class="token number">2</span> <span class="token operator">*</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// Swap right child</span>
                <span class="token keyword">int</span> tmp <span class="token operator">=</span> heap_<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
                heap_<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> heap_<span class="token punctuation">[</span><span class="token number">2</span> <span class="token operator">*</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                heap_<span class="token punctuation">[</span><span class="token number">2</span> <span class="token operator">*</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
                i <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>heap_<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> heap_<span class="token punctuation">[</span><span class="token number">2</span> <span class="token operator">*</span> i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// Swap left child</span>
                <span class="token keyword">int</span> tmp <span class="token operator">=</span> heap_<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
                heap_<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> heap_<span class="token punctuation">[</span><span class="token number">2</span> <span class="token operator">*</span> i<span class="token punctuation">]</span><span class="token punctuation">;</span>
                heap_<span class="token punctuation">[</span><span class="token number">2</span> <span class="token operator">*</span> i<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
                i <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> i<span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        cur<span class="token operator">--</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="toolbar"><div class="toolbar-item"><button class="copy-to-clipboard-button" type="button" data-copy-state="copy"><span>Copy</span></button></div></div></div>
<p>Starting from the first non-leaf node, we will percolate down, the exact same way we did in the <code class="hljs language-stylus">pop()</code> function. After each iteration, we are going to decrement the index by <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> so we can perform <code class="hljs language-stylus">heapify()</code> on the next node, all the way until index <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>.</p>
<p>The visual below demonstrates <code class="hljs language-stylus">heapify()</code> being performed on all nodes starting from index <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4</span></span></span></span>. The nodes in the blue rectangles are leaf nodes.</p>
<p><img src="https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/ef4e44b2-100b-4f72-b18d-e244ad759500/sharpen=1" alt="heapify"></p>

<h2 id="time-complexity">Time Complexity</h2>
<p>Given that there are <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> nodes in a binary tree, there are roughly <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mtext>&nbsp;</mtext><mi mathvariant="normal">/</mi><mtext>&nbsp;</mtext><mn>2</mn></mrow><annotation encoding="application/x-tex">n\ /\ 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mspace">&nbsp;</span><span class="mord">/</span><span class="mspace">&nbsp;</span><span class="mord">2</span></span></span></span> leaf nodes. Using this information, we can figure out how many levels each node has to percolate down and the amount of work <code class="hljs language-stylus">heapify()</code> performs at each level. </p>
<p>We don't perform heapify at the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span></span></span></span>rd / last level. The nodes on the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span>nd level need to percolate down one level, and the nodes on the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>st level are percolating down two levels, with the root node having to percolate down all the levels. So while the number of nodes is halving each time, the number of levels needed to be percolated increases. There is a very neat mathematical summation that is formed when we add all the work together, which simplifies to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>, but we will not be covering that. It is highly unlikely that you will be asked to prove the time complexity of <code class="hljs language-stylus">heapify()</code>, so it is enough to know that it is in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p>
<p>If you are interested in learning the proof behind why there are roughly <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mtext>&nbsp;</mtext><mi mathvariant="normal">/</mi><mtext>&nbsp;</mtext><mn>2</mn></mrow><annotation encoding="application/x-tex">n\ /\ 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mspace">&nbsp;</span><span class="mord">/</span><span class="mspace">&nbsp;</span><span class="mord">2</span></span></span></span> leaf nodes, these 5 slides from <a href="https://courses.cs.vt.edu/~cs3114/Fall09/wmcquain/Notes/T03a.BinaryTreeTheorems.pdf">Virginia Tech</a> are valuable.</p>

<h2 id="closing-notes">Closing Notes</h2>
<p>BST problems are common but when it comes to using a data structure as a utility, they are much more common with a heap. If you continously need to find the maximum or the minimum value in a problem, using a min or a max-heap are great options. </p>
<blockquote>
<p>Sometimes, the problem asks to find the "Top K" elements with some criteria. These questions are built to be solved with heaps.  </p>
</blockquote>

</div>