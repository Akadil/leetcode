<div class="my-div"><h1 id="heap-properties">Heap Properties</h1>

<p>A heap is a specialized, tree-based data structure, which is a complete binary tree. It implements an abstract data type called the Priority Queue, but sometimes 'Heap' and 'Priority Queue' are used interchangeably. </p>
<p>We already learned that queues operate with a first-in-first-out basis but with a priority queue, the values are removed based on a given priority. The element with the highest priority is removed first. </p>

<h2 id="two-types-of-heaps">Two types of heaps</h2>
<ol>
<li>Min Heap </li>
<li>Max Heap</li>
</ol>
<p><strong>Min heaps</strong> have the smallest value at the root node and when deleting, the smallest value has the highest priority. </p>
<p><strong>Max heaps</strong> have the largest value at the root node and when deleting, the largest value has the highest priority. </p>
<p>In this chapter, we will be focusing on min heaps, but the implementation is exactly the same for max heap, except you would prioritize the maximum value instead of the minimum.</p>

<h2 id="heap-properties-1">Heap Properties</h2>
<p>For a binary tree to qualify as a heap, it must satisfy the following properties:</p>
<p><strong>1. Structure Property</strong><br>A binary heap is a binary tree that is a <strong>complete binary tree</strong>, where every single level of the tree is filled completely, except the lowest level nodes, which are filled contiguously from left to right. </p>
<p><strong>2. Order Property</strong></p>
<p>The order property for a min-heap is that all of the descendents should be greater than their ancestor. In other words, if we have a tree rooted at <code class="hljs language-ebnf">y</code>, every node in the right and the left sub-tree should be greater than or equal to <code class="hljs language-ebnf">y</code>. This is a recursive property, similar to binary search trees.</p>
<p>In a max-heap, every node in the right and the left sub-tree is smaller than or equal to <code class="hljs language-ebnf">y</code>.</p>
<p>The following visual shows a binary heap.</p>
<p><img src="https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/14f4ac1b-f117-45e6-27e2-e7de3b0afa00/sharpen=1" alt="heap"></p>

<h2 id="implementation">Implementation</h2>
<p>Binary heaps are drawn using a tree data structure but under the hood, they are implemented using arrays. Let's show how we can do this by using the given binary heap: <code class="hljs language-java"><span class="token punctuation">[</span><span class="token number">14</span><span class="token punctuation">,</span><span class="token number">19</span><span class="token punctuation">,</span><span class="token number">16</span><span class="token punctuation">,</span><span class="token number">21</span><span class="token punctuation">,</span><span class="token number">26</span><span class="token punctuation">,</span><span class="token number">19</span><span class="token punctuation">,</span><span class="token number">68</span><span class="token punctuation">,</span><span class="token number">65</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">,</span><span class="token keyword">null</span><span class="token punctuation">,</span><span class="token keyword">null</span><span class="token punctuation">,</span><span class="token keyword">null</span><span class="token punctuation">,</span><span class="token keyword">null</span><span class="token punctuation">,</span><span class="token keyword">null</span><span class="token punctuation">,</span><span class="token keyword">null</span><span class="token punctuation">]</span></code></p>
<p>We will take an array of size <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> is the number of nodes in our binary heap. This will make sense soon. We will visit our nodes in the same order as we visit nodes in breadth-first search - level by level, from left to right. We will insert these into our array in a contiguous fashion. However, we will start filling them from index <code class="hljs language-undefined">1</code> instead of <code class="hljs language-undefined">0</code>, for reasons we will discuss soon. </p>
<p>Once our array has been filled up, it would look like the following: </p>
<p><img src="https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/2de1eb2d-7437-4cc9-4192-e9eaaf77d600/sharpen=1" alt="heap"></p>
<p>The reason why we start filling up our array from index <code class="hljs language-undefined">1</code> is because it helps us figure out the index at which a node's left child, right child, or the parent resides. Because binary heaps are complete binary trees, no space is required for pointers. Instead, a node's left child, right child and parent can be calculated using the following formulas, where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> is the index of a given node.</p>
<p><code class="hljs language-ebnf">leftChild</code> = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>∗</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">2 * i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span><br><code class="hljs language-ebnf">rightChild</code> = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>∗</mo><mi>i</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2 * i + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7429em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span><br><code class="hljs language-ebnf">parent</code> = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">i / 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">i</span><span class="mord">/2</span></span></span></span></p>
<p>Now, suppose we wanted to find the above properties of node <code class="hljs language-undefined">19</code>. The following visual demonstrates how using the formulas helps us figure them out. The number within the circle at each node in the tree is the value stored at that node. The number above a node (in blue) is the corresponding index in the array. It is important to note that these formulas only work when the tree is a complete binary tree. We can also now appreciate why we start at index <code class="hljs language-undefined">1</code>. Suppose we wanted to find <code class="hljs language-undefined">14</code>'s left and right child and <code class="hljs language-undefined">14</code> was at <code class="hljs language-undefined">0</code>. Well, any number multiplied by a <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>, and would tell us that the left child resides at the <code class="hljs language-undefined">0</code>th index, which is of course not the case. </p>
<p><img src="https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/d9af7215-abfe-4fbf-189c-3a82aeb98c00/sharpen=1" alt="heap"></p>
<blockquote>
<p>Whenever any operations are done on the heap, such as remove or add, we have to make sure that the min-heap properties are satisfied and the three aforementioned formulas are still valid. We will discuss this in the next chapter.</p>
</blockquote>
<p>Below is the code implementation of heap. </p>
<div class="code-toolbar"><pre class="language-cpp" tabindex="0"><code class="hljs language-cpp"><span class="token keyword">class</span> <span class="token class-name">Heap</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> heap_<span class="token punctuation">;</span>
    <span class="token function">Heap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        heap_<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="toolbar"><div class="toolbar-item"><button class="copy-to-clipboard-button" type="button" data-copy-state="copy"><span>Copy</span></button></div></div></div>

<h2 id="closing-notes">Closing Notes</h2>
<p>Looking at max heap and min heap properties, if a problem asks us to find the minimum or the maximum, a heap is a viable option. We will see how efficient it is when it comes to removal and addition operations.</p>

</div>

